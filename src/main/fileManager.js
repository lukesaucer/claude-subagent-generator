const fs = require('fs').promises;
const path = require('path');
const Store = require('electron-store');

class FileManager {
  /**
   * SECURITY FIX: Constructor now accepts Electron app object for secure path resolution
   *
   * @param {Electron.App} app - Electron app object (optional, defaults to process.cwd() for backward compatibility)
   */
  constructor(app = null) {
    this.store = new Store();

    /**
     * SECURITY FIX: Use app.getAppPath() instead of process.cwd()
     *
     * WHY THIS MATTERS:
     * - process.cwd() can be manipulated by changing directory before launch
     * - app.getAppPath() always points to the application's actual location
     * - Prevents directory traversal attacks at the root level
     *
     * BACKWARD COMPATIBILITY:
     * Falls back to process.cwd() if app object not provided
     * TODO: Remove fallback in production and require app object
     */
    this.projectRoot = app ? app.getAppPath() : process.cwd();

    this.generatedAgentsDir = path.join(this.projectRoot, '.claude', 'generated-agents');
    this.existingAgentsDir = path.join(this.projectRoot, '.claude', 'agents');
    this.templatePath = path.join(this.projectRoot, 'SUBAGENT_PROMPT_TEMPLATE.md');

    // Maximum file size for PDF processing (10MB)
    // Prevents DoS attacks via large file uploads
    this.MAX_PDF_SIZE = 10 * 1024 * 1024; // 10MB in bytes

    // Ensure directories exist
    this.ensureDirectories();
  }

  async ensureDirectories() {
    try {
      await fs.mkdir(this.generatedAgentsDir, { recursive: true });
    } catch (error) {
      console.error('Error creating directories:', error);
    }
  }

  async saveAgent(agentData) {
    const { name, content, metadata } = agentData;

    // Create safe filename
    const safeFileName = `${name
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-|-$/g, '')}.md`;

    const filePath = path.join(this.generatedAgentsDir, safeFileName);

    // Create full agent markdown with metadata
    const fullContent = this.formatAgentFile(content, metadata);

    await fs.writeFile(filePath, fullContent, 'utf-8');

    return {
      filePath,
      fileName: safeFileName,
      timestamp: new Date().toISOString(),
    };
  }

  formatAgentFile(content, metadata) {
    const timestamp = new Date().toISOString();
    return `# Subagent: ${metadata.name || 'Unnamed Agent'}

**Generated**: ${timestamp}
**Version**: 1.0.0
**Type**: ${metadata.type || 'custom'}

---

${content}

---

*Generated by Claude Subagent Generator v1.0.0*
`;
  }

  async loadGeneratedAgents() {
    try {
      const files = await fs.readdir(this.generatedAgentsDir);
      const agentFiles = files.filter((f) => f.endsWith('.md') && f !== '.gitkeep');

      const agents = await Promise.all(
        agentFiles.map(async (file) => {
          const filePath = path.join(this.generatedAgentsDir, file);
          const content = await fs.readFile(filePath, 'utf-8');
          const stats = await fs.stat(filePath);

          return {
            name: file.replace('.md', ''),
            fileName: file,
            content,
            created: stats.birthtime,
            modified: stats.mtime,
          };
        })
      );

      return agents.sort((a, b) => b.modified - a.modified);
    } catch (error) {
      console.error('Error loading generated agents:', error);
      return [];
    }
  }

  async loadExistingAgents() {
    try {
      const files = await fs.readdir(this.existingAgentsDir);
      const agentFiles = files.filter((f) => f.endsWith('.md'));

      const agents = await Promise.all(
        agentFiles.map(async (file) => {
          const filePath = path.join(this.existingAgentsDir, file);
          const content = await fs.readFile(filePath, 'utf-8');

          return {
            name: file.replace('.md', ''),
            fileName: file,
            content: `${content.substring(0, 500)}...`, // Just preview
            fullPath: filePath,
          };
        })
      );

      return agents.sort((a, b) => a.name.localeCompare(b.name));
    } catch (error) {
      console.error('Error loading existing agents:', error);
      return [];
    }
  }

  /**
   * SECURITY FIX: Added input sanitization to prevent path traversal
   *
   * Consult with an existing agent by loading its full content.
   *
   * @param {string} agentType - Agent filename without extension
   * @param {string} query - Context/question for the consultation
   * @returns {Promise<Object>} Agent content and availability status
   */
  async consultAgent(agentType, query) {
    /**
     * CRITICAL SECURITY FIX: Sanitize agentType to prevent path traversal
     *
     * VULNERABILITY FIXED:
     * Before: consultAgent('../../etc/passwd', 'query') could read /etc/passwd
     * After: Only alphanumeric characters and hyphens allowed
     *
     * SANITIZATION STEPS:
     * 1. Convert to lowercase (consistency)
     * 2. Replace all non-alphanumeric chars (except hyphens) with empty string
     * 3. Trim any leading/trailing hyphens
     * 4. Reject empty strings after sanitization
     *
     * Examples:
     * - "security-auditor" → "security-auditor" (valid)
     * - "../../etc/passwd" → "etcpasswd" (attack neutralized)
     * - "../../../" → "" (rejected as invalid)
     * - "agent@#$name" → "agentname" (special chars removed)
     */
    const safeAgentType = agentType
      .toLowerCase()
      .replace(/[^a-z0-9-]/g, '')  // Remove all unsafe characters
      .replace(/^-+|-+$/g, '');     // Trim leading/trailing hyphens

    // Reject invalid agent types (empty after sanitization)
    if (!safeAgentType) {
      return {
        agentType,
        content: null,
        query,
        available: false,
        error: 'Invalid agent type',
      };
    }

    // Construct path with sanitized filename
    const agentPath = path.join(this.existingAgentsDir, `${safeAgentType}.md`);

    /**
     * SECURITY: Additional path validation
     * Verify the resolved path is actually within the agents directory
     * This is defense-in-depth against path traversal attacks
     */
    const resolvedPath = path.resolve(agentPath);
    const resolvedBaseDir = path.resolve(this.existingAgentsDir);

    if (!resolvedPath.startsWith(resolvedBaseDir)) {
      console.error('Path traversal attempt detected:', agentType);
      return {
        agentType,
        content: null,
        query,
        available: false,
        error: 'Invalid agent path',
      };
    }

    try {
      const agentContent = await fs.readFile(agentPath, 'utf-8');

      // Return the agent content for the Head Architect to use
      return {
        agentType: safeAgentType,  // Return sanitized name
        content: agentContent,
        query,
        available: true,
      };
    } catch (error) {
      // Don't leak file system details in error message
      return {
        agentType: safeAgentType,
        content: null,
        query,
        available: false,
        error: 'Agent not found',
      };
    }
  }

  async loadTemplate() {
    try {
      const template = await fs.readFile(this.templatePath, 'utf-8');
      return template;
    } catch (error) {
      console.error('Error loading template:', error);
      return '';
    }
  }

  loadSettings() {
    return this.store.get('settings', {
      theme: 'dark',
      autoSave: true,
      consultAgents: true,
    });
  }

  saveSettings(settings) {
    this.store.set('settings', settings);
  }
}

module.exports = FileManager;
